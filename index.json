[{"authors":["admin"],"categories":null,"content":"I am a recent UCLA graduate enthusiastic about the intersections between science, technology, and society.\nCurrently, I am actively pursuing opportunities in software engineering, data science, and bioinformatics. I am excited to apply my skillset to a myriad of situations in industry. I am also adaptable to learning different languages, frameworks, and platforms.\nIn my free time, I enjoy planting trees, reading about math, and telling stories. Hopefully this website eventually grows into both a math and writing blog.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/author/sydney-birbrower/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/sydney-birbrower/","section":"authors","summary":"I am a recent UCLA graduate enthusiastic about the intersections between science, technology, and society.\nCurrently, I am actively pursuing opportunities in software engineering, data science, and bioinformatics. I am excited to apply my skillset to a myriad of situations in industry.","tags":null,"title":"Sydney Birbrower","type":"authors"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"3c42bb4157bf51d85ae7ffc4e1685909","permalink":"/projects/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/projects/","section":"","summary":"","tags":null,"title":"Projects","type":"page"},{"authors":[],"categories":["Graph Theory"],"content":"        An adjacency matrix of a graph is a data structure that encodes the relationship between the vertices and edges of the graph. For a graph with n vertices, the adjacency matrix has n rows and n columns. The vertices must be put in an (arbitrary) order from 1 to n; each row and column of the matrix then represents a distinct vertex. If two vertices i and j have an edge between them, the i,j th entry of the matrix is 1. If they don't, i,j th entry of the matrix is 0. It is convenient to think of the adjacency matrix as encoding not edges, but the neighbor relationship between two vertices. Formally, the adjacency matrix G with vertices v ∈ V(G) and edges e ∈ E(G) is given by: $$a_{ij} = \\begin{cases} 1 \u0026 \\text{if } v_i v_j \\in E(G) \\\\ 0 \u0026 \\text{if } v_i v_j \\notin E(G) \\\\ \\end{cases}$$ For the example graph G on the right, the adjacency matrix is: $$ A_G = \\left[ {\\begin{array}{cccccc} 0 \u0026 1 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \\\\ 1 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 1 \u0026 0 \u0026 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 1 \u0026 1 \u0026 1 \u0026 0 \\end{array} } \\right] $$  Now let's define a walk. A walk is an finite way of getting from one vertex to another (or back to the same vertex). You are allowed to repeat edges and vertices. A walk can even be no edges at all. The length of a walk is the number of edges traversed during the walk, counting revisits. An an example, there is a walk of length 4 from node B to node D.  Because the existence of a walk of length 1 between two vertices is the same as the neighbor relationship between two vertices, the adjacency matrix also encodes all the walks of length 1 in a graph. With this in mind, let us ask the following question: What does the adjecency matrix squared encode? $$ A^2 = \\left[ {\\begin{array}{cccccc} 3 \u0026 1 \u0026 2 \u0026 1 \u0026 2 \u0026 2 \\\\ 1 \u0026 3 \u0026 2 \u0026 2 \u0026 1 \u0026 2 \\\\ 2 \u0026 2 \u0026 5 \u0026 2 \u0026 2 \u0026 2 \\\\ 1 \u0026 2 \u0026 2 \u0026 3 \u0026 2 \u0026 1 \\\\ 2 \u0026 1 \u0026 2 \u0026 2 \u0026 3 \u0026 1 \\\\ 2 \u0026 2 \u0026 2 \u0026 1 \u0026 1 \u0026 0 \\end{array} } \\right] $$ Let's examine the entry $$A_{3,2} = A_{C,B} = 2$$ Matrix multiplication here is the product is obtained by multiplying term-by-term the entries of the 3rd row and the 2nd column and summing those products. Its the dot product. $$ \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 + 0 + 0 + 0 + 1 + 0 \\end{pmatrix} = 2 $$  The left vector above represents the neighbors of C. The right vector above represents the neighbors of B. By taking the dot product, only entries where both are not zero are represented in the sum. Therefore, this dot product represents the number of common neighbors between B and C. Since two vertices have a common neighbor if and only if a 2-walk exists between them, this matrix entry is also the number of 2-walks between B and C. Now that we know that A2 encodes the number of 2-walks betwwen any two vertices in a graph, it is natural to ask if A3 encodes 3-walks and if An encodes n-walks.   Theorem: The i,j th entry of the kth power of the adjacency matrix of a graph G is the number of different walks of length k in G between nodes i and j.   Proof by Induction: Our base case here is k=0, or the matrix of walks of length one. This is the adjacency matrix by definition. Now we need to prove that if our theorem is true for k, then it must always be true for k+1. Let's split a k-length walk from i to j up into a walk of length one from i to one of its neighbors l and a walk of length k-1 from l to j. Assuming our theorum is correct for k-1, this number of k-walks from i to j would be: $$ \\sum_{\\{v_i, v_l\\} \\in E} a_{lj}^{k-1} = \\sum_{l=1}^n a_{il} a_{lj}^{k-1} = a_{ij} $$ We are summing all the possible k-1-walks associated with each neighbor across all neighbors to get all possible k-walks from the starting node. This last summations give us matrix multiplication. Intuitively, we can think of it as finding common nodes between the path of length one and the k-1 path. Therefore, k-1 being true implies its successors k, k+1, etc. and the proof by induction is complete.  The adjacency matrix and its squares of the graph to the right are as follows: $$ A = \\left[ {\\begin{array}{cccccc} 0 \u0026 0 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\\\ 0 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \\\\ 1 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\end{array} } \\right] A^2 = \\left[ {\\begin{array}{cccccc} 4 \u0026 2 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \\\\ 2 \u0026 2 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 2 \u0026 2 \u0026 1 \u0026 1 \\\\ 1 \u0026 0 \u0026 2 \u0026 3 \u0026 1 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \u0026 2 \u0026 1 \\\\ 0 \u0026 0 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\end{array} } \\right] A^3 = \\left[ {\\begin{array}{cccccc} 2 \u0026 1 \u0026 6 \u0026 7 \u0026 5 \u0026 4 \\\\ 1 \u0026 0 \u0026 4 \u0026 5 \u0026 2 \u0026 2 \\\\ 6 \u0026 4 \u0026 0 \u0026 1 \u0026 2 \u0026 0 \\\\ 7 \u0026 5 \u0026 1 \u0026 2 \u0026 4 \u0026 1 \\\\ 5 \u0026 2 \u0026 2 \u0026 4 \u0026 2 \u0026 1 \\\\ 4 \u0026 2 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \\end{array} } \\right] $$         --       table, caption, tbody, tfoot, thead, tr, th, td { padding: 3px; border: 0; outline: 0; font-size: 6px; background: transparent; color: black; margin-left: auto; margin-right: auto; width: 100%; } .node circle { stroke: black; stroke-width: 2px; color: black; } .node text { font-family: sans-serif; text-anchor: middle; pointer-events: none; user-select: none; -webkit-user-select: none; } .link { stroke-width: 4px; } text { font: 18px sans-serif; pointer-events: none; } #end-arrow { fill: #88A; } #scrolly { position: relative; display: -webkit-box; display: -ms-flexbox; display: flex; padding: 1rem; } #scrolly* { -webkit-box-flex: 1; -ms-flex: 1; flex: 1; } .article-style { overflow-x: visible; } .article-container { max-width: 1260px; } figure { position: -webkit-sticky; position: sticky; width: 100%; margin: 0; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); z-index: 0; } figure p { text-align: center; padding: 1rem; position: absolute; top: 50%; left: 50%; -moz-transform: translate(-50%, -50%); -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); font-size: 8rem; font-weight: 900; } .step { margin: 0 auto 2rem auto; color: #C0C0C0; } .step:last-child { margin-bottom: 0; } .step.is-active { color: #3b3b3b; } .step p { text-align: center; padding: 1rem; font-size: 1.5rem; line-height: 90%; } body { font-size: 10px; font-family: 'Open Sans', sans-serif; font-weight: 400; text-align: center; } h1 { font-size: 50px; } tabletheadtrth, tabletbodytrth, tabletfoottrth, tabletheadtrtd, tabletbodytrtd, tabletfoottrtd { background-color: transparent; border-top: transparent; color: black; padding: 3px; } tabletbodytr:nth-child(odd)td, tabletbodytr:nth-child(odd)th { background-color: transparent; color: black; } th { color: black; padding: 3px; } td { color: black; padding: 3px; } .author-card .avatar { visibility: hidden; }   // I figured this could be a good way to organize the data // when reponse.index d.source.x) .attr('y1', d = d.source.y) .attr('x2', d = d.target.x) .attr('y2', d = d.target.y); node.attr('cx', d = d.x) .attr('cy', d = d.y); text.attr('x', d = d.x - 5) //position of the lower left point of the text .attr('y', d = d.y + 5); //position of the lower left point of the text edgepaths.attr('d', function (d) { var path = 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y; //console.log(d) return path }); edgelabels.attr('transform', function (d, i) { if (d.target.x 3 \u0026\u0026 response.index = 8 \u0026 d.id = 8 \u0026 d.id = 8 \u0026 d.id = 8 \u0026 d.id = 8 \u0026 d.id = 8 \u0026 d.id d.id); link.exit().remove(); link = link.enter().append('line') .style('stroke-width', 4) .merge(link); text = text.data(nodes) text.exit().remove(); text = text.enter().append('text').text(function (d) { return d.name; }).merge(text) edgepaths = edgepaths.data(links, d = d.source + \"-\" + d.target); edgepaths.exit().remove(); edgepaths = edgepaths.enter().append('path') .attr('class', 'links-path') .attr('fill-opacity', 0) .attr('stroke-opacity', 0) .attr('d', function (d) { return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y }) .attr('id', function (d, i) { return 'edgepath' + d.source.id + \"-\" + d.target.id }) .merge(edgepaths); // if I rewrite this as // edgelabels = edgelabels.data(links) // and put the svg.selectAll portion as a let statement outside of this function // it doesn't work at all? edgelabels = edgelabels.data(links, d = d.id); edgelabels.exit().remove(); edgelabels = edgelabels.enter().append('text') .attr('class', 'links-text') .attr('dx', 40) .attr('dy', 5) .attr('font-size', 3) .attr('fill', 'black') .merge(edgelabels); edgelabels.append('textPath') .attr('xlink:href', d = { return \"#edgepath\" + d.source.id + \"-\" + d.target.id; }) .text(function (d) { return d.type }).merge(edgelabels); // Update and restart the simulation. simulation.nodes(nodes); simulation.force(\"link\").links(links); simulation.alphaTarget(.1); // \"Reheat the simulation\" simulation.restart(); }  ","date":1602201600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599680123,"objectID":"a986fc6926b78821fbb4e5fc18017a5b","permalink":"/posts/adjacency-matrices/","publishdate":"2020-10-09T00:00:00Z","relpermalink":"/posts/adjacency-matrices/","section":"posts","summary":"An adjacency matrix of a graph is a data structure that encodes the relationship between the vertices and edges of the graph. For a graph with n vertices, the adjacency matrix has n rows and n columns.","tags":["Graph Theory"],"title":"Adjacency Matrices","type":"posts"},{"authors":null,"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546300800,"objectID":"b429e705db9b54d373a93574b76cc27c","permalink":"/proj/","publishdate":"2019-01-01T00:00:00Z","relpermalink":"/proj/","section":"","summary":"Showcasing my Shiny Apps","tags":null,"title":"Shiny","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"783ddc4b888b06198c5e3be34509dcc1","permalink":"/project/psychedelic_img_generator/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/psychedelic_img_generator/","section":"project","summary":"A custom flask app that allows the user to upload an image of an animal and transform it into a colorful, neon version of the same animal","tags":["Python"],"title":"Psychedelic Image Generator","type":"project"}]