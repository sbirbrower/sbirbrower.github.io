<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graph Theory | Sydney Birbrower</title>
    <link>/tag/graph-theory/</link>
      <atom:link href="/tag/graph-theory/index.xml" rel="self" type="application/rss+xml" />
    <description>Graph Theory</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 09 Oct 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Graph Theory</title>
      <link>/tag/graph-theory/</link>
    </image>
    
    <item>
      <title>Adjacency Matrices</title>
      <link>/posts/adjacency-matrices/</link>
      <pubDate>Fri, 09 Oct 2020 00:00:00 +0000</pubDate>
      <guid>/posts/adjacency-matrices/</guid>
      <description>



&lt;meta charset=&#39;utf-8&#39; /&gt;
&lt;meta http-equiv=&#39;X-UA-Compatible&#39; content=&#39;IE=edge&#39; /&gt;
  &lt;script src=&#39;https://cdnjs.cloudflare.com/ajax/libs/d3/5.15.0/d3.min.js&#39;&gt;&lt;/script&gt;
    &lt;script src=&#39;https://cdnjs.cloudflare.com/ajax/libs/d3-cloud/1.2.5/d3.layout.cloud.min.js&#39;&gt;&lt;/script&gt;
      &lt;script src=&#39;https://cdnjs.cloudflare.com/ajax/libs/scrollama/2.2.0/scrollama.js&#39;&gt;&lt;/script&gt;
        &lt;link rel=&#39;stylesheet&#39; href=&#39;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css&#39;
        integrity=&#39;sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq&#39; crossorigin=&#39;anonymous&#39;&gt;
          &lt;script defer src=&#39;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js&#39;
        integrity=&#39;sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz&#39;
        crossorigin=&#39;anonymous&#39;&gt;&lt;/script&gt;
          &lt;script defer src=&#39;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js&#39;
        integrity=&#39;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI&#39; crossorigin=&#39;anonymous&#39;
        onload=&#39;renderMathInElement(document.body);&#39;&gt;&lt;/script&gt;
          &lt;meta name=&#39;viewport&#39; content=&#39;width=device-width, initial-scale=1&#39; /&gt;
          

&lt;main&gt;

&lt;section id=&#39;scrolly&#39;&gt;
&lt;article&gt;
&lt;div class=&#39;step&#39; data-step=&#39;1&#39;&gt;
&lt;p style=&#34;font-size: 0.9rem; line-height: 130%; text-align: left;&#34;&gt;
  An adjacency matrix of a graph is a data structure that encodes the relationship between
  the vertices and edges of the graph. For a graph with n vertices, the adjacency matrix has
  n rows and n columns. The vertices must be put in an (arbitrary) order from 1 to n; 
  each row and column of the matrix then represents a distinct vertex. 
  If two vertices &lt;i style=&#34;font-family: serif;&#34;&gt;i&lt;/i&gt; and 
  &lt;i style=&#34;font-family: serif;&#34;&gt;j&lt;/i&gt; have an edge between them, the 
  &lt;i style=&#34;font-family: serif;&#34;&gt;i,j&lt;/i&gt; th entry of the matrix is 1. 
  If they don&#39;t, &lt;i style=&#34;font-family: serif;&#34;&gt;i,j&lt;/i&gt; th entry of the matrix is 0.
  It is convenient to think of the adjacency
  matrix as encoding not edges, but the neighbor relationship between two vertices.
  &lt;br&gt;
  &lt;br&gt;
  Formally, the adjacency matrix G with vertices v ∈ V(G) and edges e ∈ E(G) 
  is given by:
   
  &lt;br&gt;
  $$a_{ij} = \begin{cases} 
  1 &amp; \text{if } v_i v_j \in E(G) \\
  0 &amp; \text{if } v_i v_j \notin E(G) \\
  \end{cases}$$
  &lt;br&gt;
  For the example graph G on the right, the adjacency matrix is:
  $$ A_G = \left[ {\begin{array}{cccccc}
  0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
  1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
  1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
  1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
  0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
  0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0
  \end{array} } \right] $$
&lt;/p&gt;




&lt;/div&gt;
&lt;div class=&#39;step&#39; data-step=&#39;2&#39;&gt;
  &lt;p style=&#34;font-size: 0.9rem; line-height: 130%; text-align: center;&#34;&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    Now let&#39;s define a walk. A walk is an finite way of getting from one vertex to another
     (or back to the same vertex). You are allowed to repeat edges and vertices. A walk
      can even be no edges at all. The length of a walk is the number of edges traversed
     during the walk, counting revisits.
  &lt;/p&gt;

  &lt;p style=&#34;font-size: 0.9rem; line-height: 130%; text-align: center;&#34;&gt;
    An an example, there is a walk of length 4 from node &lt;font color=&#39;#EE5A63&#39;&gt; B&lt;/font&gt; to node &lt;font color=&#39;#EE5A63&#39;&gt; D&lt;/font&gt;.
  &lt;/p&gt;

&lt;/div&gt;



&lt;div class=&#39;step&#39; data-step=&#39;3&#39;&gt;
  &lt;p style=&#34;font-size: 0.9rem; line-height: 130%; text-align: center;&#34;&gt;
    Because the existence of a walk of length 1 between two vertices is the same as
    the neighbor relationship between two vertices, the adjacency matrix also encodes 
    all the walks of length 1 in a graph. With this in mind, let us ask the following
    question:
  &lt;br&gt;
  &lt;br&gt;

    What does the adjecency matrix squared encode?
    $$ A^2 = \left[ {\begin{array}{cccccc}
    3 &amp; 1 &amp; 2 &amp; 1 &amp; 2 &amp; 2 \\
    1 &amp; 3 &amp; 2 &amp; 2 &amp; 1 &amp; 2 \\
    2 &amp; 2 &amp; 5 &amp; 2 &amp; 2 &amp; 2 \\
    1 &amp; 2 &amp; 2 &amp; 3 &amp; 2 &amp; 1 \\
    2 &amp; 1 &amp; 2 &amp; 2 &amp; 3 &amp; 1 \\
    2 &amp; 2 &amp; 2 &amp; 1 &amp; 1 &amp; 0
    \end{array} } \right] $$

    &lt;br&gt;

    Let&#39;s examine the entry $$A_{3,2} = A_{C,B} = 2$$
    Matrix multiplication here is the product is obtained by multiplying term-by-term 
    the entries of the 3rd row and the 2nd column and summing those products. Its the dot product.

    $$
    \begin{pmatrix} 1 \\ 1 \\ 0 \\ 1 \\ 1 \\ 1 \end{pmatrix} \cdot 
    \begin{pmatrix} 1 \\ 0 \\ 1 \\ 0 \\ 1 \\ 0 \end{pmatrix} =
    \begin{pmatrix} 1 + 0 + 0 + 0 + 1 + 0 \end{pmatrix} = 2
    $$
    
  &lt;/p&gt;
&lt;/div&gt;



&lt;div class=&#39;step&#39; data-step=&#39;4&#39;&gt;
  &lt;p style=&#34;font-size: 0.9rem; line-height: 130%; text-align: center;&#34;&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    The left vector above represents the neighbors of &lt;font color=&#39;#6693FF&#39;&gt; C&lt;/font&gt;.
    The right vector above represents the neighbors of &lt;font color=&#39;#6693FF&#39;&gt; B&lt;/font&gt;.
    By taking the dot product, only entries where both are not zero are represented in the sum.
    Therefore, this dot product represents the number of common neighbors between  &lt;font color=&#39;#6693FF&#39;&gt; B&lt;/font&gt;
    and &lt;font color=&#39;#6693FF&#39;&gt; C&lt;/font&gt;. Since two vertices have a common neighbor if
    and only if a 2-walk exists between them,  
    this matrix entry is also the number of 2-walks between &lt;font color=&#39;#6693FF&#39;&gt; B&lt;/font&gt;
    and &lt;font color=&#39;#6693FF&#39;&gt; C&lt;/font&gt;. 
    Now that we know that A&lt;sup&gt;2&lt;/sup&gt;
    encodes the number of 2-walks betwwen any two vertices in a graph, it is natural
    to ask if A&lt;sup&gt;3&lt;/sup&gt;
    encodes 3-walks and if A&lt;sup&gt;n&lt;/sup&gt; encodes n-walks.
    &lt;script src=&#34;https://gist.github.com/sbirbrower/acef5730841d383d9329853b3870609e.js&#34;&gt;&lt;/script&gt;

  &lt;/p&gt;
  
&lt;/div&gt;


&lt;div class=&#39;step&#39; data-step=&#39;5&#39;&gt;
&lt;p style=&#34;font-size: 1.4rem; line-height: 130%; text-align: center;&#34;&gt;
  Theorem: &lt;br&gt;
  &lt;font color=&#39;#898989&#39;&gt;
    The &lt;i style=&#34;font-family: serif;&#34;&gt;i,j&lt;/i&gt; th entry of the kth power of the adjacency matrix of a graph G is the number of different 
    walks of length k in G between nodes &lt;i style=&#34;font-family: serif;&#34;&gt;i&lt;/i&gt; and &lt;i style=&#34;font-family: serif;&#34;&gt;j&lt;/i&gt;.
  &lt;/font&gt;
&lt;/p&gt;
&lt;/div&gt;




&lt;div class=&#39;step&#39; data-step=&#39;6&#39;&gt;
  &lt;b style=&#34;font-size: 0.9rem; line-height: 130%; text-align: center;&#34;&gt;Proof by Induction:&lt;/b&gt;

  &lt;p style=&#34;font-size: 0.9rem; line-height: 130%; text-align: left;&#34;&gt;
    Our base case here is &lt;i style=&#34;font-family: serif;&#34;&gt;k=0&lt;/i&gt;, or the matrix of walks of length one. This is the adjacency matrix 
    by definition. 
    &lt;br&gt;
    &lt;br&gt;
    Now we need to prove that if our theorem is true for &lt;i style=&#34;font-family: serif;&#34;&gt;k&lt;/i&gt;, then it must always be true for &lt;i style=&#34;font-family: serif;&#34;&gt;k+1&lt;/i&gt;.
    &lt;br&gt;
    &lt;br&gt;

    Let&#39;s split a &lt;i style=&#34;font-family: serif;&#34;&gt;k&lt;/i&gt;-length walk from &lt;i style=&#34;font-family: serif;&#34;&gt;i&lt;/i&gt; to &lt;i style=&#34;font-family: serif;&#34;&gt;j&lt;/i&gt; up into a walk of length one 
    from &lt;i style=&#34;font-family: serif;&#34;&gt; i&lt;/i&gt; to one of its neighbors &lt;i style=&#34;font-family: serif;&#34;&gt;l&lt;/i&gt; and a walk of length &lt;i style=&#34;font-family: serif;&#34;&gt;k-1&lt;/i&gt; 
    from &lt;i style=&#34;font-family: serif;&#34;&gt;l&lt;/i&gt; to &lt;i style=&#34;font-family: serif;&#34;&gt;j&lt;/i&gt;. Assuming our theorum is correct for &lt;i style=&#34;font-family: serif;&#34;&gt;k-1&lt;/i&gt;, this number 
    of &lt;i style=&#34;font-family: serif;&#34;&gt;k&lt;/i&gt;-walks from &lt;i style=&#34;font-family: serif;&#34;&gt; i&lt;/i&gt; to &lt;i style=&#34;font-family: serif;&#34;&gt; j&lt;/i&gt; would be:

    $$
    \sum_{\{v_i, v_l\} \in E} a_{lj}^{k-1} = \sum_{l=1}^n a_{il} a_{lj}^{k-1} = a_{ij}
    $$

    We are summing all the possible &lt;i style=&#34;font-family: serif;&#34;&gt;k-1&lt;/i&gt;-walks associated with each neighbor
    across all neighbors to get all possible &lt;i style=&#34;font-family: serif;&#34;&gt;k&lt;/i&gt;-walks from the starting node.

    This last summations give us matrix multiplication. 
    Intuitively, we can think of it as finding common nodes between the path of length one and 
    the &lt;i style=&#34;font-family: serif;&#34;&gt;k-1&lt;/i&gt; path.
    Therefore, &lt;i style=&#34;font-family: serif;&#34;&gt;k-1&lt;/i&gt; being true
    implies its successors &lt;i style=&#34;font-family: serif;&#34;&gt;k&lt;/i&gt;, &lt;i style=&#34;font-family: serif;&#34;&gt;k+1&lt;/i&gt;, etc. and the proof 
    by induction is complete.


  &lt;/p&gt;
&lt;/div&gt;




&lt;div class=&#39;step&#39; data-step=&#39;7&#39;&gt;
&lt;p style=&#34;font-size: 1rem; line-height: 130%; text-align: center;&#34;&#34;&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  The adjacency matrix and its squares of the graph to the right are as follows:
&lt;/p&gt;
&lt;p style=&#34;font-size: 0.7rem; line-height: 130%; text-align: center;&#34;&gt;
  $$ A = \left[ {\begin{array}{cccccc}
  0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
  0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
  1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
  1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
  1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
  \end{array} } \right] 

  A^2 = \left[ {\begin{array}{cccccc}
  4 &amp; 2 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
  2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
  0 &amp; 0 &amp; 2 &amp; 2 &amp; 1 &amp; 1 \\
  1 &amp; 0 &amp; 2 &amp; 3 &amp; 1 &amp; 1 \\
  1 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 1 \\
  0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1
  \end{array} } \right]

  A^3 = \left[ {\begin{array}{cccccc}
  2 &amp; 1 &amp; 6 &amp; 7 &amp; 5 &amp; 4 \\
  1 &amp; 0 &amp; 4 &amp; 5 &amp; 2 &amp; 2 \\
  6 &amp; 4 &amp; 0 &amp; 1 &amp; 2 &amp; 0 \\
  7 &amp; 5 &amp; 1 &amp; 2 &amp; 4 &amp; 1 \\
  5 &amp; 2 &amp; 2 &amp; 4 &amp; 2 &amp; 1 \\
  4 &amp; 2 &amp; 0 &amp; 1 &amp; 1 &amp; 0
  \end{array} } \right]
  $$
&lt;/p&gt;

&lt;/div&gt;





&lt;!-- &lt;div class=&#39;step&#39; data-step=&#39;8&#39;&gt;
&lt;/div&gt;
&lt;div class=&#39;step&#39; data-step=&#39;9&#39;&gt;
&lt;/div&gt;
&lt;div class=&#39;step&#39; data-step=&#39;10&#39;&gt;
&lt;/div&gt;
&lt;div class=&#39;step&#39; data-step=&#39;11&#39;&gt;
&lt;/div&gt;
&lt;div class=&#39;step&#39; data-step=&#39;12&#39;&gt;
&lt;/div&gt;

&lt;div class=&#39;step&#39; data-step=&#39;13&#39;&gt;
&lt;/div&gt;

&lt;div class=&#39;step&#39; data-step=&#39;15&#39;&gt;
&lt;/div&gt; --&gt;

&lt;/article&gt;

&lt;figure&gt;&lt;/figure&gt;

&lt;/section&gt;

&lt;section id=&#39;outro&#39;&gt;
  &lt;/section&gt;

&lt;/main&gt;

&lt;style&gt;
  table, caption, tbody, tfoot, thead, tr, th, td {
    padding: 3px;
    border: 0;
    outline: 0;
    font-size: 6px;
    background: transparent;
    color: black;
    margin-left: auto;
    margin-right: auto;
    width: 100%;
  }

.node circle {
  stroke: black;
  stroke-width: 2px;
  color: black;
}

.node text {
  font-family: sans-serif;
  text-anchor: middle;
  pointer-events: none;
  user-select: none;
  -webkit-user-select: none;
}

.link {
  stroke-width: 4px;
}


text {
  font: 18px sans-serif;
  pointer-events: none;
}

#end-arrow {
fill: #88A;
  }

#scrolly {
position: relative;
display: -webkit-box;
display: -ms-flexbox;
display: flex;
padding: 1rem;
}

#scrolly&gt;* {
-webkit-box-flex: 1;
-ms-flex: 1;
flex: 1;
}

.article-style {
overflow-x: visible;
}

.article-container {
max-width: 1260px;
}

figure {
position: -webkit-sticky;
position: sticky;
width: 100%;
margin: 0;
-webkit-transform: translate3d(0, 0, 0);
-moz-transform: translate3d(0, 0, 0);
transform: translate3d(0, 0, 0);
z-index: 0;
}

figure p {
text-align: center;
padding: 1rem;
position: absolute;
top: 50%;
left: 50%;
-moz-transform: translate(-50%, -50%);
-webkit-transform: translate(-50%, -50%);
transform: translate(-50%, -50%);
font-size: 8rem;
font-weight: 900;
}

.step {
margin: 0 auto 2rem auto;
color: #C0C0C0;
}

.step:last-child {
margin-bottom: 0;
}

.step.is-active {
color: #3b3b3b;
}

.step p {
text-align: center;
padding: 1rem;
font-size: 1.5rem;
line-height: 90%;
}

body {
font-size: 10px;
font-family: &#39;Open Sans&#39;, sans-serif;
font-weight: 400;
text-align: center;
}

h1 {
font-size: 50px;
}

table&gt;thead&gt;tr&gt;th, 
table&gt;tbody&gt;tr&gt;th, 
table&gt;tfoot&gt;tr&gt;th, 
table&gt;thead&gt;tr&gt;td, 
table&gt;tbody&gt;tr&gt;td, 
table&gt;tfoot&gt;tr&gt;td { 
background-color: transparent;
border-top: transparent;
color: black;
padding: 3px;
}

table&gt;tbody&gt;tr:nth-child(odd)&gt;td, table&gt;tbody&gt;tr:nth-child(odd)&gt;th {
background-color: transparent;
color: black;
}

th {
color: black;
padding: 3px;
}

td {
color: black;
padding: 3px;
}

.author-card .avatar {
  visibility: hidden;
}

&lt;/style&gt;



&lt;script&gt;
  // I figured this could be a good way to organize the data 
  // when reponse.index &lt; 4 use all_links[0] otherwise use all_links[1]

  // use color + response.index to color the links

  // using d3 for convenience
  var main = d3.select(&#39;main&#39;);
  var scrolly = main.select(&#39;#scrolly&#39;);
var figure = scrolly.select(&#39;figure&#39;);
var article = scrolly.select(&#39;article&#39;);
var step = article.selectAll(&#39;.step&#39;);

margin = {
top: 30,
right: 80,
bottom: 30,
left: 30
}

width = 590
height = 340

var simulation = d3.forceSimulation()
.force(&#39;link&#39;, d3.forceLink().id(function (d) { return d.id; }))
//.force(&#39;charge&#39;, d3.forceManyBody().strength(-200))
.force(&#39;charge&#39;, d3.forceManyBody()
     .strength(-1000)
     .distanceMax(200)
)
.force(&#39;center&#39;, d3.forceCenter(width / 2, height / 2));

var svg = figure.append(&#39;svg&#39;).attr(&#39;height&#39;, 600).attr(&#39;width&#39;, 600)


const dataset = {
nodes: [
  // graph 1 and 2
  { name: &#34;A&#34;, id: 0, color0: &#39;white&#39;, color1: &#39;#f6a4a9&#39;, color2: &#39;#C4D5FF&#39;, color3: &#39;#C4D5FF&#39;, color4: &#39;white&#39;, color5: &#39;white&#39;, color6: &#39;white&#39;, color7: &#39;#EE5A63&#39;, color8: &#39;white&#39;, color9: &#39;white&#39;, color10: &#39;white&#39;, color11: &#39;white&#39;, color12: &#39;white&#39;, color13: &#39;white&#39;, color14: &#39;#5ba860&#39; },
  { name: &#34;B&#34;, id: 1, color0: &#39;white&#39;, color1: &#39;#EE5A63&#39;, color2: &#39;#6693FF&#39;, color3: &#39;#6693FF&#39;, color4: &#39;white&#39;, color5: &#39;white&#39;, color6: &#39;white&#39;, color7: &#39;#5ba860&#39;, color8: &#39;white&#39;, color9: &#39;white&#39;, color10: &#39;white&#39;, color11: &#39;white&#39;, color12: &#39;white&#39;, color13: &#39;#EE5A63&#39;, color14: &#39;white&#39; },
  { name: &#34;C&#34;, id: 2, color0: &#39;white&#39;, color1: &#39;#f6a4a9&#39;, color2: &#39;#6693FF&#39;, color3: &#39;#6693FF&#39;, color4: &#39;white&#39;, color5: &#39;white&#39;, color6: &#39;white&#39;, color7: &#39;#EE5A63&#39;, color8: &#39;white&#39;, color9: &#39;white&#39;, color10: &#39;white&#39;, color11: &#39;white&#39;, color12: &#39;white&#39;, color13: &#39;#EE5A63&#39;, color14: &#39;white&#39; },
  { name: &#34;D&#34;, id: 3, color0: &#39;white&#39;, color1: &#39;#EE5A63&#39;, color2: &#39;#C4D5FF&#39;, color3: &#39;white&#39;, color4: &#39;white&#39;, color5: &#39;white&#39;, color6: &#39;white&#39;, color7: &#39;#EE5A63&#39;, color8: &#39;white&#39;, color9: &#39;white&#39;, color10: &#39;white&#39;, color11: &#39;white&#39;, color12: &#39;white&#39;, color13: &#39;#EE5A63&#39;, color14: &#39;white&#39; },
  { name: &#34;E&#34;, id: 4, color0: &#39;white&#39;, color1: &#39;#f6a4a9&#39;, color2: &#39;#C4D5FF&#39;, color3: &#39;#C4D5FF&#39;, color4: &#39;white&#39;, color5: &#39;white&#39;, color6: &#39;white&#39;, color7: &#39;white&#39;, color8: &#39;white&#39;, color9: &#39;white&#39;, color10: &#39;white&#39;, color11: &#39;white&#39;, color12: &#39;white&#39;, color13: &#39;white&#39;, color14: &#39;#5ba860&#39; },
  { name: &#34;F&#34;, id: 5, color0: &#39;white&#39;, color1: &#39;white&#39;, color2: &#39;#C4D5FF&#39;, color3: &#39;white&#39;, color4: &#39;white&#39;, color5: &#39;white&#39;, color6: &#39;white&#39;, color7: &#39;white&#39;, color8: &#39;white&#39;, color9: &#39;white&#39;, color10: &#39;white&#39;, color11: &#39;white&#39;, color12: &#39;white&#39;, color13: &#39;white&#39;, color14: &#39;#5ba860&#39; },
  { name: &#34;G&#34;, id: 6, color0: &#39;white&#39;, color1: &#39;white&#39;, color2: &#39;#C4D5FF&#39;, color3: &#39;white&#39;, color4: &#39;white&#39;, color5: &#39;white&#39;, color6: &#39;white&#39;, color7: &#39;white&#39;, color8: &#39;white&#39;, color9: &#39;white&#39;, color10: &#39;white&#39;, color11: &#39;white&#39;, color12: &#39;white&#39;, color13: &#39;#EE5A63&#39;, color14: &#39;white&#39; }
  ],
links: [
  // graph 1
  { id: 1, source: 0, target: 1, color0: &#39;black&#39;, color1: &#39;black&#39;, color2: &#39;#6693FF&#39;, color3: &#39;#6693FF&#39;, type: &#39;&#39;},
  { id: 2, source: 0, target: 3, color0: &#39;black&#39;, color1: &#39;#EE5A63&#39;, color2: &#39;black&#39;, color3: &#39;black&#39;, type: &#39;&#39; },
  { id: 3, source: 0, target: 2, color0: &#39;black&#39;, color1: &#39;#EE5A63&#39;, color2: &#39;#6693FF&#39;, color3: &#39;#6693FF&#39;, type: &#39;&#39; },
  { id: 4, source: 1, target: 2, color0: &#39;black&#39;, color1: &#39;black&#39;, color2: &#39;#6693FF&#39;, color3: &#39;black&#39;, type: &#39;&#39; },
  { id: 5, source: 1, target: 4, color0: &#39;black&#39;, color1: &#39;#EE5A63&#39;, color2: &#39;#6693FF&#39;, color3: &#39;#6693FF&#39;, type: &#39;&#39; },
  { id: 6, source: 3, target: 5, color0: &#39;black&#39;, color1: &#39;black&#39;, color2: &#39;black&#39;, color3: &#39;black&#39;, type: &#39;&#39; },
  { id: 7, source: 5, target: 4, color0: &#39;black&#39;, color1: &#39;black&#39;, color2: &#39;black&#39;, color3: &#39;black&#39;, type: &#39;&#39; },
  

  { id: 8, source: 2, target: 4, color0: &#39;black&#39;, color1: &#39;#EE5A63&#39;, color2: &#39;#6693FF&#39;, color3: &#39;#6693FF&#39;, type: &#39;&#39; },
  { id: 9, source: 2, target: 5, color0: &#39;black&#39;, color1: &#39;black&#39;, color2: &#39;#6693FF&#39;, color3: &#39;black&#39;, type: &#39;&#39; },
  { id: 10, source: 3, target: 2, color0: &#39;black&#39;, color1: &#39;black&#39;, color2: &#39;#6693FF&#39;, color3: &#39;black&#39;, type: &#39;&#39; },

  // graph 2

  { id: 11, source: 0, target: 5, color4: &#39;black&#39;, color5: &#39;black&#39;, color6: &#39;black&#39;, color7: &#39;black&#39;, type: &#39;&#39; },
  { id: 12, source: 0, target: 2, color4: &#39;black&#39;, color5: &#39;black&#39;, color6: &#39;black&#39;, color7: &#39;black&#39;, type: &#39;&#39; },
  { id: 13, source: 2, target: 1, color4: &#39;black&#39;, color5: &#39;black&#39;, color6: &#39;black&#39;, color7: &#39;black&#39;, type: &#39;&#39; },
  { id: 14, source: 3, target: 1, color4: &#39;black&#39;, color5: &#39;black&#39;, color6: &#39;black&#39;, color7: &#39;black&#39;, type: &#39;&#39; },
  { id: 15, source: 0, target: 3, color4: &#39;black&#39;, color5: &#39;black&#39;, color6: &#39;black&#39;, color7: &#39;black&#39;, type: &#39;&#39; },
  { id: 16, source: 4, target: 3, color4: &#39;black&#39;, color5: &#39;black&#39;, color6: &#39;black&#39;, color7: &#39;black&#39;, type: &#39;&#39; },
  { id: 17, source: 0, target: 4, color4: &#39;black&#39;, color5: &#39;black&#39;, color6: &#39;black&#39;, color7: &#39;black&#39;, type: &#39;&#39; },


  // graph 3-8
  // { id: 17, source: 0, target: 1, color8: &#39;black&#39;, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 18, source: 0, target: 2, color8: &#39;black&#39;, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 19, source: 0, target: 4, color8: &#39;black&#39;, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 20, source: 0, target: 5, color8: &#39;black&#39;, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 21, source: 1, target: 2, color8: &#39;black&#39;, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 22, source: 2, target: 5, color8: &#39;black&#39;, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 23, source: 4, target: 5, color8: &#39;black&#39;, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 24, source: 4, target: 3, color8: &#39;black&#39;, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 25, source: 4, target: 6, color8: &#39;black&#39;, color10: &#39;black&#39;, type: &#39;&#39;},
  
  // graph 3-9
  { id: 26, source: 0, target: 1, color9: &#39;black&#39;, type: &#39;1&#39;},
  { id: 27, source: 0, target: 2, color9: &#39;black&#39;, type: &#39;2&#39;},
  { id: 28, source: 0, target: 4, color9: &#39;black&#39;, type: &#39;3&#39;},
  { id: 29, source: 0, target: 5, color9: &#39;black&#39;, type: &#39;4&#39;},
  { id: 30, source: 1, target: 2, color9: &#39;black&#39;, type: &#39;5&#39;},
  { id: 31, source: 2, target: 5, color9: &#39;black&#39;, type: &#39;6&#39;},
  { id: 32, source: 4, target: 5, color9: &#39;black&#39;, type: &#39;7&#39;},
  { id: 33, source: 4, target: 3, color9: &#39;black&#39;, type: &#39;8&#39;},
  { id: 34, source: 4, target: 6, color9: &#39;black&#39;, type: &#39;9&#39;},
  
  // graph 3-10
  { id: 53, source: 0, target: 1, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 54, source: 0, target: 2, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 55, source: 0, target: 4, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 56, source: 0, target: 5, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 57, source: 1, target: 2, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 58, source: 2, target: 5, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 59, source: 4, target: 5, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 60, source: 4, target: 3, color10: &#39;black&#39;, type: &#39;&#39;},
  { id: 61, source: 4, target: 6, color10: &#39;black&#39;, type: &#39;&#39;},
  
  // graph 3-11
  { id: 35, source: 0, target: 1, color11: &#39;#EE5A63&#39;,  type: &#39;1&#39;},
  { id: 36, source: 0, target: 2, color11: &#39;#EE5A63&#39;,  type: &#39;1&#39;},
  { id: 37, source: 0, target: 4, color11: &#39;#EE5A63&#39;,  type: &#39;1&#39;},
  { id: 38, source: 0, target: 5, color11: &#39;#EE5A63&#39;,  type: &#39;1&#39;},
  { id: 39, source: 1, target: 2, color11: &#39;black&#39;, type: &#39;&#39;},
  { id: 40, source: 2, target: 5, color11: &#39;black&#39;, type: &#39;&#39;},
  { id: 41, source: 4, target: 5, color11: &#39;black&#39;, type: &#39;&#39;},
  { id: 42, source: 4, target: 3, color11: &#39;#5ba860&#39;, type: &#39;2&#39;},
  { id: 43, source: 4, target: 6, color11: &#39;#5ba860&#39;, type: &#39;2&#39;},
  
  // graph 3-11
  { id: 44, source: 0, target: 1, color12: &#39;#EE5A63&#39;, color13: &#39;black&#39;, color14: &#39;black&#39;, type: &#39;&#39;},
  { id: 45, source: 0, target: 2, color12: &#39;black&#39;, color13: &#39;black&#39;, color14: &#39;black&#39;, type: &#39;&#39;},
  { id: 46, source: 0, target: 4, color12: &#39;#EE5A63&#39;, color13: &#39;black&#39;, color14: &#39;black&#39;, type: &#39;&#39;},
  { id: 47, source: 0, target: 5, color12: &#39;black&#39;, color13: &#39;black&#39;, color14: &#39;black&#39;, type: &#39;&#39;},
  { id: 48, source: 1, target: 2, color12: &#39;black&#39;, color13: &#39;black&#39;, color14: &#39;black&#39;, type: &#39;&#39;},
  { id: 49, source: 2, target: 5, color12: &#39;black&#39;, color13: &#39;black&#39;, color14: &#39;black&#39;, type: &#39;&#39;},
  { id: 50, source: 4, target: 5, color12: &#39;black&#39;, color13: &#39;black&#39;, color14: &#39;black&#39;, type: &#39;&#39;},
  { id: 51, source: 4, target: 3, color12: &#39;#EE5A63&#39;, color13: &#39;black&#39;, color14: &#39;black&#39;, type: &#39;&#39;},
  { id: 52, source: 4, target: 6, color12: &#39;black&#39;, color13: &#39;black&#39;, color14: &#39;black&#39;, type: &#39;&#39;},
  ]
};


console.log(&#39;dataset is ...&#39;, dataset);

// Initialize the links
let link = svg.append(&#39;g&#39;)
.attr(&#39;class&#39;, &#39;links&#39;)
.selectAll(&#39;line&#39;);

// Initialize the nodes
let node = svg.append(&#39;g&#39;)
.attr(&#39;class&#39;, &#39;nodes&#39;)
.selectAll(&#39;circle&#39;);
// .enter().append(&#39;circle&#39;)

// Text to nodes
let text = svg.append(&#39;g&#39;)
.attr(&#39;class&#39;, &#39;text&#39;)
.selectAll(&#39;text&#39;)

// Edge paths for the labels
let edgepaths = svg.append(&#34;g&#34;)
.selectAll(&#34;.links-path&#34;);

// Labels for edges
let edgelabels = svg.append(&#34;g&#34;)
.selectAll(&#34;.links-text&#34;);

//Listen for tick events to render the nodes as they update in your Canvas or SVG.
simulation
.nodes(dataset.nodes)//sets the simulation’s nodes to the specified array of objects, initializing their positions and velocities, and then re-initializes any bound forces;
.on(&#39;tick&#39;, ticked);//use simulation.on to listen for tick events as the simulation runs.
// After this, Each node must be an object. The following properties are assigned by the simulation:
// index - the node’s zero-based index into nodes
// x - the node’s current x-position
// y - the node’s current y-position
// vx - the node’s current x-velocity
// vy - the node’s current y-velocity

simulation.force(&#39;link&#39;)
.links(dataset.links);//sets the array of links associated with this force, recomputes the distance and strength parameters for each link, and returns this force.
// After this, Each link is an object with the following properties:
// source - the link’s source node; 
// target - the link’s target node; 
// index - the zero-based index into links, assigned by this method


// This function is run at each iteration of the force algorithm, updating the nodes position (the nodes data array is directly manipulated).
function ticked() {
link.attr(&#39;x1&#39;, d =&gt; d.source.x)
.attr(&#39;y1&#39;, d =&gt; d.source.y)
.attr(&#39;x2&#39;, d =&gt; d.target.x)
.attr(&#39;y2&#39;, d =&gt; d.target.y);

node.attr(&#39;cx&#39;, d =&gt; d.x)
.attr(&#39;cy&#39;, d =&gt; d.y);

text.attr(&#39;x&#39;, d =&gt; d.x - 5) //position of the lower left point of the text
.attr(&#39;y&#39;, d =&gt; d.y + 5); //position of the lower left point of the text

edgepaths.attr(&#39;d&#39;, function (d) {
  var path = &#39;M &#39; + d.source.x + &#39; &#39; + d.source.y + &#39; L &#39; + d.target.x + &#39; &#39; + d.target.y;
  //console.log(d)
  return path
});

edgelabels.attr(&#39;transform&#39;, function (d, i) {
  if (d.target.x &lt; d.source.x) {
    let bbox = this.getBBox();
    let rx = bbox.x + bbox.width / 2;
    let ry = bbox.y + bbox.height / 2;
    return &#39;rotate(180 &#39; + rx + &#39; &#39; + ry + &#39;)&#39;;
  }
  else {
    return &#39;rotate(0)&#39;;
  }
});
}

//When the drag gesture starts, the targeted node is fixed to the pointer
//The simulation is temporarily “heated” during interaction by setting the target alpha to a non-zero value.
function dragstarted(d) {
if (!d3.event.active) simulation.alphaTarget(0.3).restart();//sets the current target alpha to the specified number in the range [0,1].
d.fy = d.y; //fx - the node’s fixed x-position. Original is null.
d.fx = d.x; //fy - the node’s fixed y-position. Original is null.
}

//When the drag gesture starts, the targeted node is fixed to the pointer
function dragged(d) {
d.fx = d3.event.x;
d.fy = d3.event.y;
}

//the targeted node is released when the gesture ends
function dragended(d) {
if (!d3.event.active) simulation.alphaTarget(0);
d.fx = null;
d.fy = null;

console.log(&#39;dataset after dragged is ...&#39;, dataset);
}


//////////////////////////////////////////////////////////////
/// Scrollytelling: Update node color and links
//////////////////////////////////////////////////////////////


// initialize the scrollama
var scroller = scrollama();

// generic window resize listener event
function handleResize() {
// 1. update height of step elements
var stepH = Math.floor(window.innerHeight * 0.75);
step.style(&#39;height&#39;, stepH + &#39;px&#39;);

var figureHeight = window.innerHeight / 2;
var figureMarginTop = (window.innerHeight - figureHeight) / 2;

figure
.style(&#39;height&#39;, figureHeight + &#39;px&#39;)
.style(&#39;top&#39;, figureMarginTop + &#39;px&#39;)

// 3. tell scrollama to update new element dimensions
scroller.resize();
}

// scrollama event handlers
function handleStepEnter(response) {

// response = { element, direction, index }
// add color to current step only
step.classed(&#39;is-active&#39;, function (d, i) {
  return i === response.index;
});

console.log(response.index)

colors = &#39;d.color&#39; + response.index
edge_text = &#39;d.type&#39; + response.index

// if you&#39;re at the first graph, don&#39;t use the last node [A-F]
// and only use the first 8 edges [this works]
if (response.index &lt; 4) {
    nodes = dataset.nodes.filter(function (d) { return d.id &lt; 6 })
    links = dataset.links.filter(function (d) { return d.id &lt; 11 });
    restart()
  // if you&#39;re at graph 2 
      // use nodes A-F and links 8-16
    } else if (response.index &gt; 3 &amp;&amp; response.index &lt; 8) {
      nodes = dataset.nodes.filter(function (d) { return d.id &lt; 6 });
      links = dataset.links.filter(function (d) { return d.id &gt;= 8 &amp; d.id &lt;= 18 });
      restart()
    } else if (response.index === 8) {
      // if you&#39;re at graph 3 with labels (9)
      nodes = dataset.nodes.filter(function (d) { return d.id &lt; 6 });
      links = dataset.links.filter(function (d) { return d.id &gt;= 8 &amp; d.id &lt;= 18 });
      restart();
    } else if (response.index === 9) {
  // if you&#39;re at graph 3 with labels (9)
      nodes = dataset.nodes.filter(function (d) { return d.id &lt; 6 });
      links = dataset.links.filter(function (d) { return d.id &gt;= 8 &amp; d.id &lt;= 18 });      
      restart();
    } else if (response.index === 10) {
      // if you&#39;re at graph 3 with labels (9)
      nodes = dataset.nodes.filter(function (d) { return d.id &lt; 6 });
      links = dataset.links.filter(function (d) { return d.id &gt;= 8 &amp; d.id &lt;= 18 });      
      restart();
    } else if (response.index === 11) {
  // if you&#39;re at graph 3 with labels (10)
      nodes = dataset.nodes.filter(function (d) { return d.id &lt; 6 });
      links = dataset.links.filter(function (d) { return d.id &gt;= 8 &amp; d.id &lt;= 18 });      
      restart();
    } else {
      // if you&#39;re at graph 3 use node G and the last edges
      nodes = dataset.nodes.filter(function (d) { return d.id &lt; 6 });
      links = dataset.links.filter(function (d) { return d.id &gt;= 8 &amp; d.id &lt;= 18 });
      restart();
}

node.attr(&#39;fill&#39;, function (d) { return eval(colors) })
link.style(&#39;stroke&#39;, function (d) { return eval(colors) })


}

function setupStickyfill() {
d3.selectAll(&#39;.sticky&#39;).each(function () {
  Stickyfill.add(this);
});
}

function init() {
setupStickyfill();

// 1. force a resize on load to ensure proper dimensions are sent to scrollama
handleResize();

// 2. setup the scroller passing options
// 	   this will also initialize trigger observations
// 3. bind scrollama event handlers (this can be chained like below)
scroller
.setup({
  step: &#39;#scrolly article .step&#39;,
  offset: 0.5,
  debug: false
})
.onStepEnter(handleStepEnter);

// setup resize event
window.addEventListener(&#39;resize&#39;, handleResize);
}

// kick things off
init();

function restart() {
if (simulation) simulation.stop();

// Apply the general update pattern to the nodes.
node = node.data(nodes);
node.exit().remove();

node = node.enter().append(&#39;circle&#39;)
.attr(&#39;r&#39;, 15)
.style(&#39;stroke&#39;, &#39;#777&#39;)
.style(&#39;stroke-width&#39;, 2)
.merge(node)
.call(d3.drag()  //sets the event listener for the specified typenames and returns the drag behavior.
      .on(&#39;start&#39;, dragstarted) //start - after a new pointer becomes active (on mousedown or touchstart).
      .on(&#39;drag&#39;, dragged)      //drag - after an active pointer moves (on mousemove or touchmove).
      .on(&#39;end&#39;, dragended)     //end - after an active pointer becomes inactive (on mouseup, touchend or touchcancel).
)

// Apply the general update pattern to the links.
link = link.data(links, d =&gt; d.id);
link.exit().remove();
link = link.enter().append(&#39;line&#39;)
.style(&#39;stroke-width&#39;, 4)
.merge(link);

text = text.data(nodes)
text.exit().remove();
text = text.enter().append(&#39;text&#39;).text(function (d) { return d.name; }).merge(text)

edgepaths = edgepaths.data(links, d =&gt; d.source + &#34;-&#34; + d.target);
edgepaths.exit().remove();
edgepaths = edgepaths.enter().append(&#39;path&#39;)
.attr(&#39;class&#39;, &#39;links-path&#39;)
.attr(&#39;fill-opacity&#39;, 0)
.attr(&#39;stroke-opacity&#39;, 0)
.attr(&#39;d&#39;, function (d) { return &#39;M &#39; + d.source.x + &#39; &#39; + d.source.y + &#39; L &#39; + d.target.x + &#39; &#39; + d.target.y })
.attr(&#39;id&#39;, function (d, i) { return &#39;edgepath&#39; + d.source.id + &#34;-&#34; + d.target.id })
.merge(edgepaths);

// if I rewrite this as
// edgelabels = edgelabels.data(links)
// and put the svg.selectAll portion as a let statement outside of this function
// it doesn&#39;t work at all? 
    edgelabels = edgelabels.data(links, d =&gt; d.id);
    edgelabels.exit().remove();
    edgelabels = edgelabels.enter().append(&#39;text&#39;)
      .attr(&#39;class&#39;, &#39;links-text&#39;)
      .attr(&#39;dx&#39;, 40)
      .attr(&#39;dy&#39;, 5)
      .attr(&#39;font-size&#39;, 3)
      .attr(&#39;fill&#39;, &#39;black&#39;)
      .merge(edgelabels);

    edgelabels.append(&#39;textPath&#39;)
      .attr(&#39;xlink:href&#39;, d =&gt; {
        return &#34;#edgepath&#34; + d.source.id + &#34;-&#34; + d.target.id;
      })
      .text(function (d) { return d.type }).merge(edgelabels);

    // Update and restart the simulation.
    simulation.nodes(nodes);
    simulation.force(&#34;link&#34;).links(links);
    simulation.alphaTarget(.1); // &#34;Reheat the simulation&#34;
    simulation.restart();
  }

&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>
